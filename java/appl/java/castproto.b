#
# this file contains stubs for the fcts
# declared in cast.m.  This file is 
# run through the limbo compiler in order
# to obtain valid funtion signatures which
# are then combined with cast.base (the
# dis assmebly code) to produce a valid
# cast.s. The generated cast.s will contain
# the code from cast.base and the correct
# function signatures generated by limbo
# and this file. cast.s is then run through
# the assembler to produce cast.dis.
# weird, but it works.
#
implement Cast;

include "jni.m";


#
# to JObject
#
FromJArray( o : JNI->JArray ) : JNI->JObject
{ junk := o; return(nil); }

FromJClass( o : JNI->JClass ) : JNI->JObject
{ junk := o; return(nil); }

FromJString( o : JNI->JString ) : JNI->JObject
{ junk := o; return(nil); }

#
# cast JArray* to JArray
#
ByteToJArray( o : ref JNI->ByteArray ) : JNI->JArray
{ junk := o; return(nil); }

IntToJArray( o : ref JNI->IntArray ) : JNI->JArray
{ junk := o; return(nil); }

BigToJArray( o : ref JNI->BigArray ) : JNI->JArray
{ junk := o; return(nil); }

RealToJArray( o : ref JNI->RealArray ) : JNI->JArray
{ junk := o; return(nil); }

ClassToJArray( o : ref JNI->ClassArray ) : JNI->JArray
{ junk := o; return(nil); }

StringToJArray( o : ref JNI->StringArray ) : JNI->JArray
{ junk := o; return(nil); }

ObjectToJArray( o : ref JNI->ObjectArray ) : JNI->JArray
{ junk := o; return(nil); }

#
# cast JArray to JArray*
#
JArrayToByte( ptr : JNI->JArray ) : ref JNI->ByteArray
{ junk := ptr; return(nil); }

JArrayToInt( ptr : JNI->JArray ) : ref JNI->IntArray
{ junk := ptr; return(nil); }

JArrayToBig( ptr : JNI->JArray ) : ref JNI->BigArray
{ junk := ptr; return(nil); }

JArrayToReal( ptr : JNI->JArray ) : ref JNI->RealArray
{ junk := ptr; return(nil); }

JArrayToClass( ptr : JNI->JArray ) : ref JNI->ClassArray
{ junk := ptr; return(nil); }

JArrayToString( ptr : JNI->JArray ) : ref JNI->StringArray
{ junk := ptr; return(nil); }

JArrayToObject( ptr : JNI->JArray ) : ref JNI->ObjectArray
{ junk := ptr; return(nil); }


#
# cast from JObjects
#
ToJClass( o : JNI->JObject ) : JNI->JClass
{ junk := o; return(nil); }

ToJString( o : JNI->JObject ) : JNI->JString
{ junk := o; return(nil); }

ToJArray( o : JNI->JObject ) : JNI->JArray
{ junk := o; return(nil); }

ToJArrayB( o : JNI->JObject ) : JNI->JArrayB
{ junk := o; return(nil); }

ToJArrayC( o : JNI->JObject ) : JNI->JArrayC
{ junk := o; return(nil); }

ToJArrayS( o : JNI->JObject ) : JNI->JArrayS
{ junk := o; return(nil); }

ToJArrayI( o : JNI->JObject ) : JNI->JArrayI
{ junk := o; return(nil); }

ToJArrayJ( o : JNI->JObject ) : JNI->JArrayJ
{ junk := o; return(nil); }

ToJArrayF( o : JNI->JObject ) : JNI->JArrayF
{ junk := o; return(nil); }

ToJArrayD( o : JNI->JObject ) : JNI->JArrayD
{ junk := o; return(nil); }

ToJArrayZ( o : JNI->JObject ) : JNI->JArrayZ
{ junk := o; return(nil); }

ToJArrayJString( o : JNI->JObject ) : JNI->JArrayJString
{ junk := o; return(nil); }

ToJArrayJObject( o : JNI->JObject ) : JNI->JArrayJObject
{ junk := o; return(nil); }

#
# cast for thread data
JObjToJThd( o  : JNI->JObject ) : (JNI->JThread)
{ junk := o; return(nil); }

JThdToJObj( o : JNI->JThread ) : (JNI->JObject)
{ junk := o; return(nil); }

#
# misc casts
#
Class2Niladt( o : JNI->ClassData ) : ref Loader->Niladt
{ junk := o; return(nil); }

Obj2Niladt( o : JNI->JObject   ) : ref Loader->Niladt
{ junk := o; return(nil); }

JNI2Nilmod( o : JNI ) : Nilmod
{ junk := o; return(nil); }

JArrayToHolder( o : array of JNI->JArray ) : array of JNI->JString
{ junk := o; return(nil); }
